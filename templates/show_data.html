<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

	<link rel="stylesheet" href="{{ url_for('static', filename='vendor/bootstrap.min.css') }}">
	<style>
		body {
			height: 100%;
			width: 100%;
			position: absolute;
		}

		#main {
			display: flex;
			flex-flow: column;
			height: 100%;
			position: relative;
		}

		#chart {
			flex-grow: 1;
		}

		svg {
			position: absolute;
		}

		text {
			font-family: 'Trebuchet MS', 'Lucida Sans Unicode', 'Lucida Grande', 'Lucida Sans', Arial, sans-serif;
			text-anchor: middle;
			font-size: 10px;
			font-weight: bolder;
			fill: black;
			text-shadow: 0px 0px 2px white;
		}

		line {
			stroke-width: 1;
			stroke: #ccc;
			marker-end: url(#out_of_path);
		}

		.path_link line {
			stroke-width: 2;
			stroke: #222;
			marker-end: url(#in_path);
		}

		circle {
			fill: #ccc;
		}

	</style>
</head>

<body class="bg-light">

	<div id="main">
		<div class="py-5 text-center">
			<h1>Graphical Web Crawler - Grus</h1>
			<p class="lead">Results of a {{ "breadth" if type == "bfs" else "depth" }} first search on {{url}}{% if keyword %} for the word "{{keyword}}"{% endif %}</p>
		</div>

		<div id="chart"></div>

		<footer class="pt-5 text-muted text-center text-small">
			<p class="mb-1">CS467 Capstone - Team Grus</p>
			<a href="https://github.com/anberns/grus">Source</a>
		</footer>
	</div>

	<script src="{{ url_for('static', filename='vendor/jquery.min.js') }}"></script>
	<script src="{{ url_for('static', filename='vendor/d3.min.js') }}"></script>
	<script src="https://rawgit.com/joewalnes/reconnecting-websocket/master/reconnecting-websocket.min.js"></script>
	<script>
		var margin = {
			top: 10,
			right: 15,
			bottom: 10,
			left: 15
		};

		var width = 425 - margin.left - margin.right;
		var height = 625 - margin.top - margin.bottom;
		var old_nodes;


		// Create the svg where the visualization will reside
		var svg = d3.select('#chart')
			.append('svg')
			.attr('width', width + margin.left + margin.right)
			.attr('height', height + margin.top + margin.bottom)
			.call(responsivefy)
			.call(d3.zoom().on("zoom", function () {
				svg.attr("transform", d3.event.transform)
			 }))
			.append('g')
			.attr('transform', `translate(${margin.left}, ${margin.top})`);

		// Create the force simulation that governs the forces on the nodes
		var simulation = d3.forceSimulation()
			.force("link", d3.forceLink().id(d => d.url))
			.force("charge", d3.forceManyBody().distanceMax(250))
			.force("center", d3.forceCenter(width / 2, height / 2))
			.force("collide", d3.forceCollide(d => d.visited ? 20 : 0))
			.on("tick", ticked);

		// Create arrows to show directionality
		svg.append("svg:defs").selectAll("marker")
			.data(["in_path", "out_of_path"])
			.enter().append("svg:marker")
			.attr("id", String)
			.attr("viewBox", "0 -5 10 10")
			.attr("refX", 15)
			.attr("refY", 0)
			.attr("markerWidth", d => d == "in_path" ? 4 : 0)
			.attr("markerHeight", d => d == "in_path" ? 4 : 0)
			.attr('fill', "#222")
			.attr("orient", "auto")
			.append("svg:path")
			.attr("d", "M0,-5L10,0L0,5");
		
		// A selection of all of the visual representations of the links
		var link = svg.append("g")
			.attr("class", "links")
			.selectAll("line");

		// A selection of all of the visual representations of the sites
		var node = svg.append("g")
			.attr("class", "nodes")
			.selectAll("circle");

		// A selection of all of the visual representations of the links in the path
		var path_link = svg.append("g")
			.attr("class", "path_link")
			.selectAll("line");

		// A selection of all of the visual representations of the sites in the path
		var path_node = svg.append("g")
			.attr("class", "path_node")
			.selectAll("circle");

		// A selection of all of the visual representations of the site names
		var title = svg.append("g")
			.attr("class", "titles")
			.selectAll("text");


		/**
		 * Reformat data from the server to fit the format of the visualization
		 *
		 * @param {*} json_data Json data from the server
		 */
		function parse_data(site) {
			var old_sites = d3.selectAll('circle').data(),
				old_links = d3.selectAll('line').data();

			var old_site = old_sites.find(el => el.url == site.url);

			site.visited = true;

			if (old_site) {
				for (var prop in site) {
					old_site[prop] = site[prop];
				}
			} else {
				old_sites.push(site);
			}

			// Add a link for a site we visited
			if (site.parent) {
				old_links.find(el => el.source.url == site.parent &&
					el.target.url == site.url).in_path = true;
			}

			// Add links to ones found on pages
			site.links.forEach(href => {
				if (old_sites.findIndex(el => el.url == href) == -1) {
					// Add a new site to our list of sites
					old_sites.push({
						url: href,
						x: old_site ? old_site.x : width / 2,
						y: old_site ? old_site.y : height / 2
					});
				}
				old_links.push({
					source: site.url,
					target: href,
					in_path: false
				});
			});

			update({
				nodes: old_sites,
				links: old_links
			});
		}
		/**
		 * Sets the data used for the visualization
		 *
		 * @param {*} data Object containing the nodes and links to use for the viz
		 */
		function update(data) {

			// Update links
			link = link.data(data.links.filter(el => !el.in_path), d => d.source.url + "-" + d.target.url);

			// Delete removed links
			link.exit().remove();

			// Add any new links
			link = link.enter().append("line").merge(link);


			// Update nodes
			node = node.data(data.nodes.filter(el => !el.visited), d => d.url)
				.attr("r", 3);

			// Delete removed sites
			node.exit().remove();

			// Add any new sites
			node = node.enter().append("circle")
				.attr("r", 3)
				.call(d3.drag()
					.on("start", drag_started)
					.on("drag", dragged)
					.on("end", drag_ended))
				.merge(node);

			// Show URL on hover
			node.append("title")
				.text(d => d.url);

			// Update links
			path_link = path_link.data(data.links.filter(el => el.in_path), d => d.source.url + "-" + d.target.url);

			// Delete removed links
			path_link.exit().remove();

			// Add any new links
			path_link = path_link.enter().append("line").merge(path_link);


			// Update nodes
			path_node = path_node.data(data.nodes.filter(el => el.visited), d => d.url)
				.attr("fill", d => d.found ? "#33AA66" : "#222")
				.attr("r", d => d.found ? 8 : 5);

			// Delete removed sites
			path_node.exit().remove();

			// Add any new sites
			path_node = path_node.enter().append("circle")
				.attr("fill", d => d.found ? "#33AA66" : "#222")
				.attr("r", d => d.found ? 8 : 5)
				.call(d3.drag()
					.on("start", drag_started)
					.on("drag", dragged)
					.on("end", drag_ended))
				.merge(path_node);

			// Show URL on hover
			path_node.append("title")
				.text(d => d.url);

			// Update titles
			title = title.data(data.nodes.filter(el => el.visited), d => d.url)
				.text(d => d.title);

			// Delete removed sites
			title.exit().remove();

			// Add any new sites
			title = title.enter().append("text")
				.text(d => d.title)
				.call(d3.drag()
					.on("start", drag_started)
					.on("drag", dragged)
					.on("end", drag_ended))
				.merge(title);

			// Show URL on hover
			title.append("title")
				.text(d => d.url);

			// Set the nodes and links for the visualization
			simulation.nodes(data.nodes);
			simulation.force("link").links(data.links);
			simulation.alpha(0.3).restart();
		}

		function ticked() {
			link.attr("x1", d => d.source.x)
				.attr("y1", d => d.source.y)
				.attr("x2", d => d.target.x)
				.attr("y2", d => d.target.y);

			node.attr("cx", d => d.x)
				.attr("cy", d => d.y);

			path_link.attr("x1", d => d.source.x)
				.attr("y1", d => d.source.y)
				.attr("x2", d => d.target.x)
				.attr("y2", d => d.target.y);

			path_node.attr("cx", d => d.x)
				.attr("cy", d => d.y);

			title.attr("x", d => d.x)
				.attr("y", d => d.y);
		}

		function drag_started(d) {
			if (!d3.event.active) simulation.alphaTarget(0.3).restart();
			d.fx = d.x;
			d.fy = d.y;
		}

		function dragged(d) {
			d.fx = d3.event.x;
			d.fy = d3.event.y;
		}

		function drag_ended(d) {
			if (!d3.event.active) simulation.alphaTarget(0);
			d.fx = null;
			d.fy = null;
		}

		function responsivefy(svg) {
			var container = d3.select(svg.node().parentNode),
				width = parseInt(svg.style("width")),
				height = parseInt(svg.style("height"));

			svg.attr("viewBox", "0 0 " + width + " " + height)
				.call(resize);

			d3.select(window).on("resize." + container.attr("id"), resize);

			function resize() {
				var target_width = parseInt(container.style("width"));
				var target_height = parseInt(container.style("height"));
				svg.attr("width", target_width);
				svg.attr("height", target_height);
			}
		}

		// If there is a data property sent in the response from the server,
		// Use that as the source for data
		var data = {{data|tojson}};
		if (data) {
			var parsed_data = JSON.parse(data);
			for (var prop in parsed_data) {
				parse_data(parsed_data[prop]);
			}
		} else {

			// Set up the location of the host websocket
			var scheme = window.location.protocol == 'https:' ? 'wss://' : 'ws://';
			var host = scheme + location.host + "/crawl";
			create_socket(host);

			// Start up the client websocket
			function create_socket(hostname) {
				var ws = new WebSocket(hostname);

				ws.onmessage = function(event) {
					parse_data(JSON.parse(event.data));
				};

				ws.onopen = function() {
					console.log("Socket Connected");
				};

				ws.onerror = function() {
					console.log("Socket Error: " + event.code);
				};

				ws.onclose = function(event) {
					console.log("Socket Closed: " + event.reason);
					console.log("Close Code: " + event.code);
					//setTimeout(reconnect(hostname), 1000);
				};
			}

			function reconnect(hostname) {
				console.log("Reconnecting....");
				create_socket(hostname);
			}

		}
	</script>
	</body>

</html>
